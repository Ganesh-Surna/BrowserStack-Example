{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/GaneshSurna/Desktop/New React/Practice_routes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/GaneshSurna/Desktop/New React/Practice_routes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _context$fetchOptions, _context$state$data, _context$state$data2, _ref2;\n        var options, direction, oldPages, oldPageParams, empty, cancelled, addSignalProperty, queryFn, fetchPage, result, previous, pageParamFn, oldData, param, _oldPageParams$, remainingPages, i, _param;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              options = context.options;\n              direction = (_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 || (_context$fetchOptions = _context$fetchOptions.meta) === null || _context$fetchOptions === void 0 || (_context$fetchOptions = _context$fetchOptions.fetchMore) === null || _context$fetchOptions === void 0 ? void 0 : _context$fetchOptions.direction;\n              oldPages = ((_context$state$data = context.state.data) === null || _context$state$data === void 0 ? void 0 : _context$state$data.pages) || [];\n              oldPageParams = ((_context$state$data2 = context.state.data) === null || _context$state$data2 === void 0 ? void 0 : _context$state$data2.pageParams) || [];\n              empty = {\n                pages: [],\n                pageParams: []\n              };\n              cancelled = false;\n              addSignalProperty = function addSignalProperty(object) {\n                Object.defineProperty(object, \"signal\", {\n                  enumerable: true,\n                  get: function get() {\n                    if (context.signal.aborted) {\n                      cancelled = true;\n                    } else {\n                      context.signal.addEventListener(\"abort\", function () {\n                        cancelled = true;\n                      });\n                    }\n                    return context.signal;\n                  }\n                });\n              };\n              queryFn = context.options.queryFn || function () {\n                return Promise.reject(new Error(\"Missing queryFn: '\".concat(context.options.queryHash, \"'\")));\n              };\n              fetchPage = function fetchPage(_x, _x2, _x3) {\n                return (_ref2 = _ref2 || _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data, param, previous) {\n                  var queryFnContext, page, maxPages, addTo;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!cancelled) {\n                          _context.next = 2;\n                          break;\n                        }\n                        return _context.abrupt(\"return\", Promise.reject());\n                      case 2:\n                        if (!(param == null && data.pages.length)) {\n                          _context.next = 4;\n                          break;\n                        }\n                        return _context.abrupt(\"return\", Promise.resolve(data));\n                      case 4:\n                        queryFnContext = {\n                          queryKey: context.queryKey,\n                          pageParam: param,\n                          direction: previous ? \"backward\" : \"forward\",\n                          meta: context.options.meta\n                        };\n                        addSignalProperty(queryFnContext);\n                        _context.next = 8;\n                        return queryFn(queryFnContext);\n                      case 8:\n                        page = _context.sent;\n                        maxPages = context.options.maxPages;\n                        addTo = previous ? addToStart : addToEnd;\n                        return _context.abrupt(\"return\", {\n                          pages: addTo(data.pages, page, maxPages),\n                          pageParams: addTo(data.pageParams, param, maxPages)\n                        });\n                      case 12:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee);\n                }))).apply(this, arguments);\n              };\n              if (!(direction && oldPages.length)) {\n                _context2.next = 19;\n                break;\n              }\n              previous = direction === \"backward\";\n              pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n              oldData = {\n                pages: oldPages,\n                pageParams: oldPageParams\n              };\n              param = pageParamFn(options, oldData);\n              _context2.next = 16;\n              return fetchPage(oldData, param, previous);\n            case 16:\n              result = _context2.sent;\n              _context2.next = 32;\n              break;\n            case 19:\n              _context2.next = 21;\n              return fetchPage(empty, (_oldPageParams$ = oldPageParams[0]) !== null && _oldPageParams$ !== void 0 ? _oldPageParams$ : options.initialPageParam);\n            case 21:\n              result = _context2.sent;\n              remainingPages = pages !== null && pages !== void 0 ? pages : oldPages.length;\n              i = 1;\n            case 24:\n              if (!(i < remainingPages)) {\n                _context2.next = 32;\n                break;\n              }\n              _param = getNextPageParam(options, result);\n              _context2.next = 28;\n              return fetchPage(result, _param);\n            case 28:\n              result = _context2.sent;\n            case 29:\n              i++;\n              _context2.next = 24;\n              break;\n            case 32:\n              return _context2.abrupt(\"return\", result);\n            case 33:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n    }\n  };\n}\nfunction getNextPageParam(options, _ref3) {\n  var pages = _ref3.pages,\n    pageParams = _ref3.pageParams;\n  var lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);\n}\nfunction getPreviousPageParam(options, _ref4) {\n  var _options$getPreviousP;\n  var pages = _ref4.pages,\n    pageParams = _ref4.pageParams;\n  return (_options$getPreviousP = options.getPreviousPageParam) === null || _options$getPreviousP === void 0 ? void 0 : _options$getPreviousP.call(options, pages[0], pages, pageParams[0], pageParams);\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"names":["addToEnd","addToStart","infiniteQueryBehavior","pages","onFetch","context","fetchFn","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","_context$fetchOptions","_context$state$data","_context$state$data2","_ref2","options","direction","oldPages","oldPageParams","empty","cancelled","addSignalProperty","queryFn","fetchPage","result","previous","pageParamFn","oldData","param","_oldPageParams$","remainingPages","i","_param","wrap","_callee2$","_context2","prev","next","fetchOptions","meta","fetchMore","state","data","pageParams","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","Promise","reject","Error","concat","queryHash","_x","_x2","_x3","_callee","queryFnContext","page","maxPages","addTo","_callee$","_context","abrupt","length","resolve","queryKey","pageParam","sent","stop","apply","arguments","getPreviousPageParam","getNextPageParam","initialPageParam","_ref3","lastIndex","_ref4","_options$getPreviousP","call","hasNextPage","hasPreviousPage"],"sources":["C:\\Users\\GaneshSurna\\Desktop\\New React\\Practice_routes\\node_modules\\@tanstack\\query-core\\src\\infiniteQueryBehavior.ts"],"sourcesContent":["import { addToEnd, addToStart } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = async () => {\n        const options = context.options as InfiniteQueryPageParamsOptions<TData>\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        const empty = { pages: [], pageParams: [] }\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              new Error(`Missing queryFn: '${context.options.queryHash}'`),\n            ))\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: Omit<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        let result: InfiniteData<unknown>\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          // Fetch first page\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam,\n          )\n\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch remaining pages\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result)\n            result = await fetchPage(result, param)\n          }\n        }\n\n        return result\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams,\n  )\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams,\n  )\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}